<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Numeric Across Categorical in R — Hands-On Guide</title>
  <link href="https://fonts.googleapis.com/css2?family=STIX+Two+Text:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#ffffff; --panel:#ffffff; --ink:#0f172a; --muted:#475569; --brand:#1d4ed8; --accent:#059669;
      --chip:#f1f5f9; --border:#e2e8f0; --code:#f8fafc;
    }
    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.6 "STIX Two Text","Times New Roman",Times,serif}
    h1{font-size:28px;margin:0 0 8px}
    h2{font-size:24px;margin:22px 0 8px}
    h3{font-size:18px;margin:18px 0 8px}
    .lead{font-size:18px}
    .wrap{max-width:1100px;margin:0 auto;padding:24px}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:16px;margin-bottom:20px}
    .viz{background:var(--chip);border:1px solid var(--border);border-radius:14px;padding:10px}
    .chip{display:inline-block;background:var(--chip);border:1px solid var(--border);padding:2px 8px;border-radius:999px;font-size:12px}
    pre{background:var(--code);border:1px solid var(--border);border-radius:10px;padding:12px;overflow:auto}
    .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .mini-note{color:var(--muted);font-size:14px;margin-top:6px}
    .footer{margin:28px 0 8px;color:var(--muted);font-size:14px}
  </style>
</head>
<body>
  <header class="panel" style="position:sticky;top:0;z-index:10;backdrop-filter:saturate(1.2) blur(6px)">
    <div class="wrap" style="padding:8px 24px">
      <h1>Numeric Across Categorical in R</h1>
      <div class="controls">
        <span class="chip">Live demo data</span>
        <label>Groups:
          <input id="k" type="range" min="2" max="6" value="4"> <strong id="kval">4</strong>
        </label>
        <label>n per group:
          <input id="n" type="range" min="30" max="1200" value="200" step="10"> <strong id="nval">200</strong>
        </label>
        <label>Separation:
          <input id="sep" type="range" min="0" max="2.5" value="1.2" step="0.1"> <strong id="sepval">1.2</strong>
        </label>
        <label>Shape:
          <select id="shape">
            <option value="normal">Unimodal (Normal-ish)</option>
            <option value="skew">Right-skewed</option>
            <option value="bimodal">Bimodal within group</option>
            <option value="outliers">Unimodal + outliers</option>
          </select>
        </label>
        <button id="regen" class="chip">Regenerate</button>
      </div>
      <div class="mini-note">Demo generator: for group <code>g</code> (0…k−1), mean ≈ <code>(g − (k−1)/2) × separation</code> plus shape-specific noise.</div>
    </div>
  </header>

  <main class="wrap">
    <section class="panel">
      <p class="lead">We’re exploring a single <strong>numeric</strong> response (e.g., score, height) broken down by a <strong>categorical</strong> factor (e.g., group, treatment). Use these plots to compare <em>centers</em>, <em>spread</em>, <em>shape</em>, and <em>outliers</em> across groups.</p>
    </section>

    <!-- 1) Grouped Box Plots -->
    <section id="box" class="panel">
      <h2>1) Box plots by group</h2>
      <div id="viz-box" class="viz" role="img" aria-label="Grouped box plots"></div>
      <details><summary>R / ggplot2</summary>
<pre><code class="language-r">library(tidyverse)
# df with columns: group (factor), y (numeric)
ggplot(df, aes(group, y, fill = group)) +
  geom_boxplot(width = 0.6, outlier.alpha = 0.6) +
  labs(title = "Box plots by group", x = NULL, y = "y") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")</code></pre>
      </details>
    </section>

    <!-- 2) Violin Plots -->
    <section id="violin" class="panel">
      <h2>2) Violin plots (distribution shape)</h2>
      <div id="viz-violin" class="viz" role="img" aria-label="Violin plots"></div>
      <details><summary>R / ggplot2</summary>
<pre><code class="language-r">ggplot(df, aes(group, y, fill = group)) +
  geom_violin(trim = FALSE, alpha = 0.8) +
  labs(title = "Violin plots by group", x = NULL, y = "y") +
  theme_minimal() +
  theme(legend.position = "none")</code></pre>
      </details>
    </section>

    <!-- 3) Beeswarm / Strip -->
    <section id="beeswarm" class="panel">
      <h2>3) Beeswarm / Strip (show all points)</h2>
      <div id="viz-beeswarm" class="viz" role="img" aria-label="Beeswarm/strip plot"></div>
      <details><summary>R / ggplot2</summary>
<pre><code class="language-r"># With jitter (built-in)
ggplot(df, aes(group, y, color = group)) +
  geom_jitter(width = 0.15, alpha = 0.5) +
  theme_minimal() + theme(legend.position = "none")

# True beeswarm (requires ggbeeswarm)
# install.packages("ggbeeswarm")
library(ggbeeswarm)
ggplot(df, aes(group, y, color = group)) +
  geom_quasirandom(alpha = 0.6, width = 0.25) +
  theme_minimal() + theme(legend.position = "none")</code></pre>
      </details>
    </section>

    <!-- 4) Raincloud (half-violin + box + jitter) -->
    <section id="rain" class="panel">
      <h2>4) Raincloud plots (half-violin + box + jitter)</h2>
      <div id="viz-rain" class="viz" role="img" aria-label="Raincloud plots"></div>
      <details><summary>R / ggplot2</summary>
<pre><code class="language-r"># Raincloud pattern with half-violin + box + jitter
ggplot(df, aes(y = group, x = y, fill = group)) +
  ggridges::geom_density_ridges(
    jittered_points = TRUE, scale = 0.9, alpha = 0.7, point_alpha = 0.25) +
  labs(title = "Raincloud-style ridges (alt)") +
  theme_minimal()

# Or manual: half-violin + box + jitter
ggplot(df, aes(y = group, x = y, fill = group)) +
  ggdist::stat_halfeye(adjust = 0.7, justification = -0.2, .width = 0, point_colour = NA) +
  geom_boxplot(width = .15, outlier.shape = NA) +
  geom_jitter(height = .1, alpha = .25) +
  theme_minimal()</code></pre>
      </details>
    </section>

    <!-- 5) Overlaid densities -->
    <section id="density" class="panel">
      <h2>5) Overlaid densities (KDE)</h2>
      <p class="mini-note">Great for shape comparison. Use transparency; avoid if groups overlap heavily or if exact counts matter.</p>
      <div id="viz-density" class="viz" role="img" aria-label="Overlaid densities"></div>
      <details><summary>R / ggplot2</summary>
<pre><code class="language-r">ggplot(df, aes(y, fill = group, color = group)) +
  geom_density(alpha = 0.35) +
  labs(title = "Overlaid densities", x = "y", y = "Density") +
  theme_minimal()</code></pre>
      </details>
    </section>

    <!-- 6) Ridgeline / Joy -->
    <section id="ridge" class="panel">
      <h2>6) Ridgeline (joy) plots</h2>
      <div id="viz-ridge" class="viz" role="img" aria-label="Ridgeline densities"></div>
      <details><summary>R / ggplot2</summary>
<pre><code class="language-r"># Requires ggridges
# install.packages("ggridges")
library(ggridges)
ggplot(df, aes(x = y, y = group, fill = group)) +
  geom_density_ridges(scale = 1.2, rel_min_height = 0.01, alpha = 0.85, color = NA) +
  theme_minimal() + theme(legend.position = "none")</code></pre>
      </details>
    </section>

    <!-- 7) Mean ± CI -->
    <section id="mean" class="panel">
      <h2>7) Means with 95% CI</h2>
      <div id="viz-mean" class="viz" role="img" aria-label="Means with CI"></div>
      <details><summary>R / ggplot2</summary>
<pre><code class="language-r"># Precompute summaries (recommended)
summ <- df %>%
  group_by(group) %>%
  summarise(mean = mean(y), se = sd(y)/sqrt(n()), .groups = "drop") %>%
  mutate(ci = 1.96 * se)

ggplot(summ, aes(group, mean, color = group)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean - ci, ymax = mean + ci), width = 0.15) +
  labs(title = "Mean ± 95% CI", x = NULL, y = "y") +
  theme_minimal() + theme(legend.position = "none")</code></pre>
      </details>
    </section>

    <!-- 8) Faceted histograms -->
    <section id="facets" class="panel">
      <h2>8) Faceted histograms (small multiples)</h2>
      <div id="viz-facets" class="viz" role="img" aria-label="Faceted histograms"></div>
      <details><summary>R / ggplot2</summary>
<pre><code class="language-r">ggplot(df, aes(y, fill = group)) +
  geom_histogram(bins = 30, color = "white") +
  facet_wrap(~ group, nrow = 1) +
  theme_minimal() + theme(legend.position = "none")</code></pre>
      </details>
    </section>

    <section class="panel">
      <h2>Pitfalls & tips</h2>
      <ul>
        <li><strong>Overplotting:</strong> prefer beeswarm/violin/ridgeline over raw scatter when n is large.</li>
        <li><strong>Comparability:</strong> align common axes/limits across facets; keep binwidths consistent.</li>
        <li><strong>Outliers:</strong> box+strip or rainclouds reveal them better than means.</li>
        <li><strong>Skew:</strong> consider log/x transforms; report medians alongside means.</li>
        <li><strong>Color:</strong> use a qualitative palette for groups; ensure sufficient contrast.</li>
      </ul>
    </section>

    <div class="footer">Made with ❤️ for R users. Copy, tweak, and ship.</div>
  </main>

  <!-- D3 for on-page visuals -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    const W=940,H=340,M={t:20,r:20,b:40,l:50};
    const innerW=W-M.l-M.r, innerH=H-M.t-M.b;
    const SMALL_H=220, SMALL_INNER_H=SMALL_H-M.t-M.b;
    const $=sel=>document.querySelector(sel);
    const colors = d3.schemeTableau10;

    // ---------- Data generator ----------
    function randn(n, m=0, s=1){ return d3.range(n).map(()=> d3.randomNormal(m,s)()); }
    function rlogn(n, mu=0, sd=0.5, shift=0){
      // center roughly then shift by mu
      const z = d3.range(n).map(()=> d3.randomLogNormal(0, sd)());
      const med = d3.quantile(z, 0.5);
      return z.map(v=> (v - med) + mu + shift);
    }
    function sampleGroups(k, n, sep, shape){
      const groups = d3.range(k).map(i => String.fromCharCode(65+i)); // A, B, C...
      const mu0 = (k-1)/2;
      let rows=[];
      groups.forEach((g, i)=>{
        const mu = (i - mu0) * sep;
        if(shape==='normal'){
          rows = rows.concat(randn(n, mu, 1).map(y=>({group:g, y})));
        }else if(shape==='skew'){
          rows = rows.concat(rlogn(n, mu, 0.6).map(y=>({group:g, y})));
        }else if(shape==='bimodal'){
          const n1=Math.floor(n*0.5), n2=n-n1;
          const a = randn(n1, mu-0.8, 0.7), b = randn(n2, mu+0.8, 0.7);
          rows = rows.concat(a.concat(b).map(y=>({group:g, y})));
        }else if(shape==='outliers'){
          const base = randn(n-3, mu, 1);
          const outs = [mu+4.5, mu-4.0, mu+5.5];
          rows = rows.concat(base.concat(outs).map(y=>({group:g, y})));
        }
      });
      return rows;
    }

    // ---------- KDE helpers ----------
    function kernelEpanechnikov(k){ return v => Math.abs(v/=k) <= 1 ? 0.75*(1-v*v)/k : 0; }
    function kde(kernel, X){ return V => X.map(x => [x, d3.mean(V, v => kernel(x - v))]); }

    // ---------- Grouped summaries ----------
    function byGroup(data){
      const map = d3.group(data, d=>d.group);
      return Array.from(map, ([group, arr]) => ({group, values: arr.map(d=>d.y)}));
    }
    function stats(values){
      const s = values.slice().sort(d3.ascending);
      const q1 = d3.quantileSorted(s, 0.25),
            med= d3.quantileSorted(s, 0.50),
            q3 = d3.quantileSorted(s, 0.75);
      const iqr = q3 - q1;
      const lo = s.find(v => v >= q1 - 1.5*iqr) ?? s[0];
      const hi = [...s].reverse().find(v => v <= q3 + 1.5*iqr) ?? s[s.length-1];
      const mean = d3.mean(s);
      const se = (d3.deviation(s) || 0)/Math.sqrt(s.length);
      return {q1, med, q3, iqr, lo, hi, mean, se, n: s.length, outliers: s.filter(v => v<lo || v>hi)};
    }

    // ---------- Frames ----------
    function frame(sel, width=W, height=H){
      const svg=d3.select(sel).html("").append("svg").attr("viewBox",`0 0 ${width} ${height}`);
      const g=svg.append("g").attr("transform",`translate(${M.l},${M.t})`);
      const innerW=width-M.l-M.r, innerH=height-M.t-M.b;
      g.append("g").attr("class","x-axis").attr("transform",`translate(0,${innerH})`);
      g.append("g").attr("class","y-axis");
      return {svg,g,innerW,innerH};
    }

    // ---------- Plots ----------
    function drawBox(data){
      const groups = byGroup(data);
      const cats = groups.map(d=>d.group);
      const all = data.map(d=>d.y);
      const ydom = d3.extent(all); const pad=(ydom[1]-ydom[0])*0.08; ydom[0]-=pad; ydom[1]+=pad;

      const {g,innerW,innerH} = frame('#viz-box');
      const x = d3.scaleBand().domain(cats).range([0, innerW]).padding(0.25);
      const y = d3.scaleLinear().domain(ydom).nice().range([innerH,0]);
      g.select('.x-axis').call(d3.axisBottom(x));
      g.select('.y-axis').call(d3.axisLeft(y));

      groups.forEach((gi, idx)=>{
        const s = stats(gi.values);
        const cx = x(gi.group), w = x.bandwidth();
        // whiskers
        g.append("line").attr("x1", cx+w/2).attr("x2", cx+w/2).attr("y1", y(s.lo)).attr("y2", y(s.q1)).attr("stroke","#334155");
        g.append("line").attr("x1", cx+w/2).attr("x2", cx+w/2).attr("y1", y(s.q3)).attr("y2", y(s.hi)).attr("stroke","#334155");
        g.append("line").attr("x1", cx+w*0.28).attr("x2", cx+w*0.72).attr("y1", y(s.lo)).attr("y2", y(s.lo)).attr("stroke","#334155");
        g.append("line").attr("x1", cx+w*0.28).attr("x2", cx+w*0.72).attr("y1", y(s.hi)).attr("y2", y(s.hi)).attr("stroke","#334155");
        // box
        g.append("rect").attr("x", cx+w*0.15).attr("y", y(s.q3))
          .attr("width", w*0.70).attr("height", Math.max(1, y(s.q1)-y(s.q3)))
          .attr("fill", colors[idx%colors.length]).attr("opacity",0.85).attr("stroke","#ffffff");
        // median
        g.append("line").attr("x1", cx+w*0.15).attr("x2", cx+w*0.85).attr("y1", y(s.med)).attr("y2", y(s.med))
          .attr("stroke","#0f172a").attr("stroke-width",2);
        // outliers
        g.selectAll(`.out-${idx}`).data(s.outliers).enter().append("circle")
          .attr("cx", cx+w/2).attr("cy", d=>y(d)).attr("r",2.5).attr("fill","#0f172a").attr("opacity",0.7);
      });
    }

    function drawViolin(data){
      const groups = byGroup(data);
      const cats = groups.map(d=>d.group);
      const all = data.map(d=>d.y);
      const ydom = d3.extent(all); const pad=(ydom[1]-ydom[0])*0.08; ydom[0]-=pad; ydom[1]+=pad;

      const {g,innerW,innerH} = frame('#viz-violin');
      const x = d3.scaleBand().domain(cats).range([0, innerW]).padding(0.25);
      const y = d3.scaleLinear().domain(ydom).nice().range([innerH,0]);
      const maxWidth = x.bandwidth()*0.9;
      g.select('.x-axis').call(d3.axisBottom(x));
      g.select('.y-axis').call(d3.axisLeft(y));

      groups.forEach((gi, idx)=>{
        const vals = gi.values;
        const bw = 1.06 * (d3.deviation(vals)||1) * Math.pow(vals.length, -1/5);
        const X = d3.range(ydom[0], ydom[1], (ydom[1]-ydom[0])/180);
        const dens = kde(kernelEpanechnikov(bw), X)(vals);
        const scaleW = d3.scaleLinear().domain([0, d3.max(dens, d=>d[1])||1]).range([0, maxWidth/2]);

        const x0 = x(gi.group) + x.bandwidth()/2;
        const path = d3.path();
        // upper (right)
        for(let i=0;i<dens.length;i++){
          const xx = x0 + scaleW(dens[i][1]);
          const yy = y(dens[i][0]);
          if(i===0) path.moveTo(xx, yy); else path.lineTo(xx, yy);
        }
        // lower (left)
        for(let i=dens.length-1;i>=0;i--){
          const xx = x0 - scaleW(dens[i][1]);
          const yy = y(dens[i][0]);
          path.lineTo(xx, yy);
        }
        path.closePath();
        g.append("path").attr("d", path.toString())
          .attr("fill", colors[idx%colors.length]).attr("opacity",0.85).attr("stroke","#ffffff");
      });
    }

    // Beeswarm using force simulation per group (numeric on y, categories on x)
    function drawBeeswarm(data){
      const groups = byGroup(data);
      const cats = groups.map(d=>d.group);
      const all = data.map(d=>d.y);
      const ydom = d3.extent(all); const pad=(ydom[1]-ydom[0])*0.08; ydom[0]-=pad; ydom[1]+=pad;

      const {g,innerW,innerH} = frame('#viz-beeswarm');
      const x = d3.scaleBand().domain(cats).range([0, innerW]).padding(0.3);
      const y = d3.scaleLinear().domain(ydom).nice().range([innerH,0]);
      g.select('.x-axis').call(d3.axisBottom(x));
      g.select('.y-axis').call(d3.axisLeft(y));

      const r = 3;
      groups.forEach((gi, idx)=>{
        const cx = x(gi.group) + x.bandwidth()/2;
        const nodes = gi.values.map(v => ({x: cx, y: y(v)}));
        const sim = d3.forceSimulation(nodes)
          .force("x", d3.forceX(cx).strength(0.05))
          .force("y", d3.forceY(d => d.y).strength(1))
          .force("collide", d3.forceCollide(r+0.5))
          .stop();
        for(let i=0;i<200;i++) sim.tick(); // settle

        g.append("g").selectAll("circle").data(nodes).enter().append("circle")
          .attr("cx", d=>d.x).attr("cy", d=>d.y).attr("r", r)
          .attr("fill", colors[idx%colors.length]).attr("opacity",0.45);
      });
    }

    // Raincloud: horizontal half-violin + box + jitter
    function drawRaincloud(data){
      const groups = byGroup(data);
      const cats = groups.map(d=>d.group);
      const all = data.map(d=>d.y);
      const xdom = d3.extent(all); const pad=(xdom[1]-xdom[0])*0.08; xdom[0]-=pad; xdom[1]+=pad;

      const {g,innerW,innerH} = frame('#viz-rain', W, 360);
      const x = d3.scaleLinear().domain(xdom).nice().range([0, innerW]);
      const y = d3.scaleBand().domain(cats).range([0, innerH]).padding(0.35);
      g.select('.x-axis').call(d3.axisBottom(x));
      g.select('.y-axis').call(d3.axisLeft(y));

      groups.forEach((gi, idx)=>{
        const vals = gi.values;
        const bw = 1.06 * (d3.deviation(vals)||1) * Math.pow(vals.length, -1/5);
        const X = d3.range(xdom[0], xdom[1], (xdom[1]-xdom[0])/180);
        const dens = kde(kernelEpanechnikov(bw), X)(vals);
        const scaleH = d3.scaleLinear().domain([0, d3.max(dens, d=>d[1])||1]).range([0, y.bandwidth()*0.9]);

        const y0 = y(gi.group) + y.bandwidth()/2;
        const path = d3.path();
        // half violin (on top side)
        path.moveTo(x(dens[0][0]), y0);
        dens.forEach(d=>{
          const xx = x(d[0]);
          const yy = y0 - scaleH(d[1]);
          path.lineTo(xx, yy);
        });
        path.lineTo(x(dens[dens.length-1][0]), y0);
        path.closePath();

        g.append("path").attr("d", path.toString())
          .attr("fill", colors[idx%colors.length]).attr("opacity",0.75).attr("stroke","#ffffff");

        // box
        const s = stats(vals);
        g.append("rect")
          .attr("x", x(s.q1)).attr("y", y0 - y.bandwidth()*0.10)
          .attr("width", Math.max(1, x(s.q3)-x(s.q1))).attr("height", y.bandwidth()*0.20)
          .attr("fill", "#ffffff").attr("stroke", "#0f172a").attr("opacity",0.9);
        g.append("line").attr("x1", x(s.med)).attr("x2", x(s.med))
          .attr("y1", y0 - y.bandwidth()*0.10).attr("y2", y0 + y.bandwidth()*0.10).attr("stroke","#0f172a").attr("stroke-width",2);
        // jittered points
        const jitter = d3.randomNormal(0, y.bandwidth()*0.08);
        g.append("g").selectAll("circle").data(vals).enter().append("circle")
          .attr("cx", d=>x(d)).attr("cy", ()=> y0 + jitter())
          .attr("r", 2.2).attr("fill", colors[idx%colors.length]).attr("opacity",0.35);
      });
    }

    // Overlaid densities
    function drawOverlaidDensities(data){
      const groups = byGroup(data);
      const cats = groups.map(d=>d.group);
      const all = data.map(d=>d.y);
      const xdom = d3.extent(all); const pad=(xdom[1]-xdom[0])*0.08; xdom[0]-=pad; xdom[1]+=pad;

      const {g,innerW,innerH} = frame('#viz-density');
      const x = d3.scaleLinear().domain(xdom).nice().range([0, innerW]);
      const y = d3.scaleLinear().range([innerH,0]); // domain set after computing densities
      g.select('.x-axis').call(d3.axisBottom(x));

      // compute densities & find max
      let allD = [];
      let ymax = 0;
      groups.forEach((gi)=>{
        const vals = gi.values;
        const bw = 1.06 * (d3.deviation(vals)||1) * Math.pow(vals.length, -1/5);
        const X = d3.range(xdom[0], xdom[1], (xdom[1]-xdom[0])/220);
        const dens = kde(kernelEpanechnikov(bw), X)(vals);
        allD.push({group:gi.group, dens});
        ymax = Math.max(ymax, d3.max(dens, d=>d[1])||0);
      });
      y.domain([0, ymax*1.05]);
      g.select('.y-axis').call(d3.axisLeft(y).ticks(5));

      allD.forEach((entry, idx)=>{
        g.append("path").datum(entry.dens)
          .attr("d", d3.area().x(d=>x(d[0])).y0(innerH).y1(d=>y(d[1])))
          .attr("fill", colors[idx%colors.length]).attr("opacity", 0.35);
        g.append("path").datum(entry.dens)
          .attr("d", d3.line().x(d=>x(d[0])).y(d=>y(d[1])))
          .attr("fill","none").attr("stroke", colors[idx%colors.length]);
      });
    }

    // Ridgeline densities (stacked by group)
    function drawRidgeline(data){
      const groups = byGroup(data);
      const cats = groups.map(d=>d.group);
      const all = data.map(d=>d.y);
      const xdom = d3.extent(all); const pad=(xdom[1]-xdom[0])*0.08; xdom[0]-=pad; xdom[1]+=pad;

      const height = 28 + cats.length*60;
      const {g,innerW,innerH} = frame('#viz-ridge', W, Math.max(220,height));
      const x = d3.scaleLinear().domain(xdom).nice().range([0, innerW]);
      const y = d3.scaleBand().domain(cats).range([0, innerH]).padding(0.35);
      g.select('.x-axis').call(d3.axisBottom(x));
      g.select('.y-axis').call(d3.axisLeft(y));

      groups.forEach((gi, idx)=>{
        const vals = gi.values;
        const bw = 1.06 * (d3.deviation(vals)||1) * Math.pow(vals.length, -1/5);
        const X = d3.range(xdom[0], xdom[1], (xdom[1]-xdom[0])/200);
        const dens = kde(kernelEpanechnikov(bw), X)(vals);
        const maxd = d3.max(dens, d=>d[1])||1;
        const amp = y.bandwidth()*0.9;
        const base = y(gi.group) + y.bandwidth()/1.05;

        const area = d3.area()
          .x(d=>x(d[0]))
          .y0(base)
          .y1(d=> base - (d[1]/maxd)*amp);

        g.append("path").datum(dens)
          .attr("d", area)
          .attr("fill", colors[idx%colors.length]).attr("opacity",0.85).attr("stroke","#ffffff");
      });
    }

    // Means with CI
    function drawMeansCI(data){
      const groups = byGroup(data).map(d=> ({group:d.group, ...stats(d.values)}));
      const cats = groups.map(d=>d.group);
      const all = data.map(d=>d.y);
      const ydom = d3.extent(all); const pad=(ydom[1]-ydom[0])*0.08; ydom[0]-=pad; ydom[1]+=pad;

      const {g,innerW,innerH} = frame('#viz-mean');
      const x = d3.scaleBand().domain(cats).range([0, innerW]).padding(0.4);
      const y = d3.scaleLinear().domain(ydom).nice().range([innerH,0]);
      g.select('.x-axis').call(d3.axisBottom(x));
      g.select('.y-axis').call(d3.axisLeft(y));

      groups.forEach((gi, idx)=>{
        const ci = 1.96 * gi.se;
        const cx = x(gi.group) + x.bandwidth()/2;
        g.append("line")
          .attr("x1", cx).attr("x2", cx)
          .attr("y1", y(gi.mean-ci)).attr("y2", y(gi.mean+ci))
          .attr("stroke", colors[idx%colors.length]).attr("stroke-width", 3).attr("opacity",0.9);
        g.append("circle").attr("cx", cx).attr("cy", y(gi.mean)).attr("r", 4.5)
          .attr("fill", colors[idx%colors.length]).attr("stroke","#0f172a").attr("stroke-width",1);
      });
    }

    // Faceted histograms (row of small multiples)
    function drawFacets(data){
      const groups = byGroup(data);
      const cats = groups.map(d=>d.group);
      const all = data.map(d=>d.y);
      const xdom = d3.extent(all);
      const width = W, height = 200, per = Math.min(5, cats.length);
      const cellW = (width - M.l - M.r) / cats.length;

      const root = d3.select('#viz-facets').html("");
      const svg = root.append("svg").attr("viewBox", `0 0 ${width} ${height}`);
      const g = svg.append("g").attr("transform", `translate(${M.l},${M.t})`);
      const innerH = height - M.t - M.b;

      groups.forEach((gi, idx)=>{
        const x = d3.scaleLinear().domain(xdom).nice().range([idx*cellW, (idx+1)*cellW - 6]);
        const bins = d3.bin().domain(x.domain()).thresholds(24)(gi.values);
        const y = d3.scaleLinear().domain([0, d3.max(bins, d=>d.length) || 1]).range([innerH, 0]);

        const gg = g.append("g");
        gg.selectAll("rect").data(bins).enter().append("rect")
          .attr("x", d=>x(d.x0)+1).attr("y", d=>y(d.length))
          .attr("width", d=>Math.max(0, x(d.x1)-x(d.x0)-2)).attr("height", d=>innerH - y(d.length))
          .attr("fill", colors[idx%colors.length]).attr("opacity",0.8).attr("stroke","#ffffff");

        // axes (mini)
        gg.append("g").attr("transform", `translate(0,${innerH})`)
          .call(d3.axisBottom(x).ticks(4)).selectAll("text").style("font-size","10px");
        gg.append("text").attr("x", (idx*cellW + (idx+1)*cellW)/2 - 10).attr("y", -6)
          .attr("text-anchor","middle").text(gi.group).style("font-size","12px");
      });
    }

    // ---------- Render ----------
    function renderAll(){
      const k = +$('#k').value; $('#kval').textContent = k;
      const n = +$('#n').value; $('#nval').textContent = n;
      const sep = +$('#sep').value; $('#sepval').textContent = sep.toFixed(1);
      const shape = $('#shape').value;

      const data = sampleGroups(k, n, sep, shape);

      drawBox(data);
      drawViolin(data);
      drawBeeswarm(data);
      drawRaincloud(data);
      drawOverlaidDensities(data);
      drawRidgeline(data);
      drawMeansCI(data);
      drawFacets(data);
    }

    // ---------- Bind ----------
    ['k','n','sep','shape'].forEach(id => document.getElementById(id).addEventListener('input', renderAll));
    document.getElementById('regen').addEventListener('click', renderAll);
    renderAll();
  </script>
</body>
</html>
